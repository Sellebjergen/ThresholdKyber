from circuit import sha3_256
from Compiler import floatingpoint

# Params (Kyber512)
n = 256
q = 3329
r = 2

cbit = cbits.get_type(1)

# _____________________ Centre + bit op _______________________

# Centre
def centre(x_i_angle):
    # BitDecomp
    b = x_i_angle.bit_decompose(bit_length = 12)

    # BitAdd
    q_plus_1 = cint(q + 1)
    qp1_bits = q_plus_1.bit_decompose(bit_length = 12)
    b_prime = floatingpoint.BitAdd(flipBits(b), qp1_bits)

    # BitNeg
    b_prime_prime = bitNeg(b_prime)

    # BitLT
    q_div_2 = cint(1665).bit_decompose(bit_length = 12)
    f=floatingpoint.BITLT(b, q_div_2, 12)

    # Compute <a>
    a = []
    for i in range(len(b)):
        a.append(f * b[i] + (1 - f) * b_prime_prime[i])

    return a

def flipBits(a_angle):
    flipped = []
    for i in range(len(a_angle)):
        flipped.append(sint.bit_not(a_angle[i]))
    return flipped

def bitNeg(a_angle):
    flipped = flipBits(a_angle)
    one = cint(1)
    one_decomp = one.bit_decompose(bit_length = len(flipped))
    return floatingpoint.BitAdd(flipped, one_decomp)

# _____________________ Rq arith. _______________________

def inner_prod(u, s):
    d = Array(n, sint)
    for i in range(r):
        d_i = rq_mult(u[i], s[i], n)
        for j in range(n):
            d[j] += d_i[j]
    return d

def rq_mult(a, b, f_n):
    prod = poly_mult(a, b)
    rem = poly_rem(prod, f_n)
    return rem

def poly_mult(a, b):
    res = Array(len(a) + len(b), sint)
    for i in range(len(a)):
        for j in range(len(b)):
            res[i + j] = res[i + j] + a[i] * b[j]
    return res

def poly_sub(a, b):
    res = Array(len(b), sint)
    for i in range(len(a)):
        res[i] = a[i] - b[i]
    return res

# Only supports f_n => 2*len(a), this is enough in our case
def poly_rem(a, f_n):
    if len(a) <= f_n:
        return a
    rem = Array(f_n, sint)
    for i in range(len(a)):
        if i < f_n:
            rem[i] += a[i]
        else:
            rem[i % f_n] -= a[i]
    return rem

# _____________________ main functionality _______________________

# KEM decapsulation:
def kem_decap(u, v, s_angle):
    # v - u^T <s>
    x = inner_prod(u, s_angle)
    x = poly_sub(v, x)
    print_ln("%s", x[0].reveal()) # BUG: SHOULD BE REDUCED MOD 3329, BUT IT IS NOT
    w = [[]] * n
    for i in range(n):
        w[i] = centre(x[i])
    k = []
    for i in range(len(w)):
        k.append(w[i][len(w[i]) - 1]) # get msb of each w_i
    return k

# Hash check:
def hash_check(k_angle, c_2):
    k_as_sbits = []
    for i in range(len(k_angle)):
        k_as_sbits.append(sbit(k_angle[i]))
    digest = sha3_256(sbitvec.from_vec(k_as_sbits + c_2).reverse_bytes())
    digest.reveal_print_hex()

# Message extraction
def msg_ext(k_angle):
    k_bits_clear = Array(n, cint)
    for i in range(len(k_angle)):
        k_bits_clear[i] = k_angle[i].reveal()
    k_bits_clear.print_reveal_nested()

# _____________________ Testing _______________________

def test_ddec(ct_1, ct_2, s_angle, c2, c3):
    # Run protocol
    k_angle = kem_decap(ct_1, ct_2, s_angle)
    #hash_check(k_angle, c2) # Conversion of sint to sbit is huge time sink, commented out for testing
    msg_ext(k_angle)

# Testing of centered
def test_centre():
    # Result should be 111010110111 (-329, see https://www.exploringbinary.com/twos-complement-converter/)
    centered = centre(sint(3000))
    print_ln(len(centered))
    for i in range(len(centered)):
        print_ln("%s", centered[i].reveal())

    # Should just return standard bit representation of 1000, since 1000 < q/2
    centered2 = centre(sint(1000)) 
    print_ln(len(centered2))
    for i in range(len(centered2)):
        print_ln("%s", centered2[i].reveal())

# Testing of rq_mul
# Should return [-12, 18] corresponding to -12 + 18x
def test_rq_mult(): 
    lhs = Array(4, sint)
    lhs[0], lhs[1] = sint(3), sint(3)

    rhs = Array(3, cint)
    rhs[0], rhs[1] = cint(1), cint(5)

    res = rq_mult(lhs, rhs, 2)
    res.print_reveal_nested()

# _____________________ Get Input _______________________

def read_s_from_file():
    s = Matrix(r, n, sint)
    for i in range(r):
        for j in range(n):
            s[i][j] = sint.get_input_from(0)
    return s

def read_public_values_from_file():
    u = Matrix(r, n, cint)
    v = Array(n, cint)
    c2 = [cbit(0)] * (256+128)
    c3 = [cbit(0)] * 256

    for i in range(r):
        for j in range(n):
            u[i][j] = public_input()

    for i in range(n):
        v[i] = public_input()

    for i in range(256+128): # IV + C2
        c2[i] = cbit(public_input())

    for i in range(256):
        c3[i] = cbit(public_input())

    return u, v, c2, c3

def test_input():
    s_angle = read_s_from_file()
    s_angle.print_reveal_nested()
    u, v, c2, c3 = read_public_values_from_file()
    u.print_reveal_nested()
    v.print_reveal_nested()

    for i in range(n):
        print_ln("%s", c2[i])

    for i in range(n):
        print_ln("%s", c3[i])

# _____________________ Main _______________________
s_angle = read_s_from_file()

u, v, c2, c3 = read_public_values_from_file()

#test_centre()
#test_rq_mult()
test_ddec(u, v, s_angle, c2, c3)
#test_input()