from circuit import sha3_256

# Params (Kyber512)
n = 256
q = 3329
r = 2

# Centre:
#
# Input:
# Output:
def centre(x_i_angle):
    # BitDecomp
    b = x_i_angle.bit_decompose(bit_length = 12)

    # BitAdd
    q_plus_1 = cint(q + 1)
    qp1_bits = q_plus_1.bit_decompose(bit_length = 12)
    b_prime = sint.bit_adder(flipBits(b), qp1_bits)

    # BitNeg
    b_prime_prime = bitNeg(b_prime)

    # BitLT
    f = x_i_angle < 1665

    # Compute <a>
    a = []
    for i in range(len(b)):
        a.append(f * b[i] + (1 - f) * b_prime_prime[i])

    return a

def flipBits(a_angle):
    flipped = []
    for i in range(len(a_angle)):
        flipped.append(sint.bit_not(a_angle[i]))
    return flipped

def bitNeg(a_angle):
    flipped = flipBits(a_angle)
    one = cint(1)
    one_decomp = one.bit_decompose(bit_length = len(flipped))
    return sint.bit_adder(flipped, one_decomp)

# KEM decapsulation:
#
# Input:
# Output:
def kem_decap(u, v, s_angle):
    # v - u^T <s>
    x = inner_prod(u, s_angle)
    x = poly_sub(v, x)
    w = Array(n, sint)
    @for_range_opt_multithread(16, n)
    def _(i):
        w[i] = centre(x[i])[11] # w.append(centre(x[i]))
    k = []
    for i in range(len(w)):
        k.append(w[i]) # get msb of each w_i
    return k

def inner_prod(u, s):
    d = Array(n, sint)
    for i in range(r):
        d_i = rq_mult(u.get_column(i), s.get_column(i), n)
        for j in range(n):
            d[j] = d[j] + d_i[j]
    return d

def rq_mult(a, b, f_n):
    prod = poly_mult(a, b)
    rem = poly_rem(prod, f_n)
    return rem

def poly_mult(a, b):
    res = Array(len(a) + len(b), sint)
    for i in range(len(a)):
        for j in range(len(b)):
            res[i + j] = res[i + j] + a[i] * b[j]
    return res

def poly_sub(a, b):
    res = Array(len(b), sint)
    for i in range(len(a)):
        res[i] = a[i] - b[i]
    return res

# Only supports f_n => 2*len(a), this is enough in our case
def poly_rem(a, f_n):
    if len(a) <= f_n:
        return a
    rem = Array(f_n, sint)
    for i in range(len(a)):
        if i < f_n:
            rem[i] += a[i]
        else:
            rem[i % f_n] -= a[i]
    return rem

# Hash check:
#
# Input:
# Output:
def hash_check(k_angle, c_2):
    k_as_sbits = []
    for i in range(len(k_angle)):
        k_as_sbits.append(sbit(k_angle[i]))
    digest = sha3_256(sbitvec.from_vec(k_angle + c_2).reverse_bytes())
    digest.reveal_print_hex()

# Message extraction: Does not output the message m, but rather the key k
# The message can then be extracted using the key outside MP-SPDZ. This is more efficient (i think).
#
# Input: k_bits is an array of sint(0)/sint(1) values representing the bits of the key
# Output: The key k.
def msg_ext(k_angle):
    k_bits_clear = Array(n, cint)
    for i in range(len(k_angle)):
        k_bits_clear[i] = k_angle[i].reveal()
    k_bits_clear.print_reveal_nested()

def test_ddec(ct_1, ct_2, s_angle, c2, c3):
    # Run protocol
    k_angle = kem_decap(ct_1, ct_2, s_angle)
    hash_check(k_angle, c2) # Conversion of sint to sbit is huge time sink, commented out for testing
    msg_ext(k_angle)

# Testing of centered
# Result should be 111010110111 (-329, see https://www.exploringbinary.com/twos-complement-converter/)
def test_centre():
    centered = centre(sint(3000))
    print_ln(len(centered))
    for i in range(len(centered)):
        print_ln("%s", centered[i].reveal())

    # Should just return standard bit representation of 1000, since 1000 < q/2
    centered2 = centre(sint(1000)) 
    print_ln(len(centered2))
    for i in range(len(centered2)):
        print_ln("%s", centered2[i].reveal())

# Testing of rq_mul
# Should return [-12, 18] corresponding to -12 + 18x
def test_rq_mult(): 
    lhs = Array(4, sint)
    lhs[0], lhs[1] = sint(3), sint(3)

    rhs = Array(3, cint)
    rhs[0], rhs[1] = cint(1), cint(5)

    res = rq_mult(lhs, rhs, 2)
    res.print_reveal_nested()

# Concrete input
cbit = cbits.get_type(1)
c2 = [cbit(0)] * n
c3 = [cbit(0)] * n

s_angle = Matrix(n, r, sint)
ct_1 = Matrix(n, r, cint)
ct_2 = Array(n, cint)

#test_centre()
#test_rq_mult()
test_ddec(ct_1, ct_2, s_angle, c2, c3)
#centre(sint(3329))