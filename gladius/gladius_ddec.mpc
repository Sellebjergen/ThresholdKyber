from circuit import sha3_256
from Compiler import floatingpoint
from Compiler.GC import types
program.use_edabit(True)
cbit = cbits.get_type(1)

n = 100
mu = 128
nu = 7 # This is x where mu = 2^x
q = 2097143
p = 512
ell = 524288
t = 2

# _____________________ Centre + bit op _______________________

# Centre
def centre(x_i_angle):
    # BitDecomp
    b = floatingpoint.BitDecFull(x_i_angle, 21)
    """ print_ln("%s", x_i_angle.reveal())
    for i in range(len(b)):
        print_ln("%s", b[i].reveal()) """

    # BitAdd
    qp1_bits = cint(q + 1).bit_decompose(bit_length = 21)
    b_prime = floatingpoint.BitAdd(flipBits(b), qp1_bits)

    # BitNeg
    b_prime_prime = bitNeg(b_prime)

    # BitLT
    q_div_2 = cint(1665).bit_decompose(bit_length = 21)
    f=floatingpoint.BITLT(b, q_div_2, 21)

    # Compute <a>
    a = []
    for i in range(len(b)):
        a.append(f * b[i] + (1 - f) * b_prime_prime[i])

    return a

def flipBits(a_angle):
    return [sint.bit_not(bit) for bit in a_angle]

def bitNeg(a_angle):
    flipped = flipBits(a_angle)
    one_decomp = [cint(1)] + [cint(0)] * (len(flipped) - 1)
    return floatingpoint.BitAdd(flipped, one_decomp)

# _____________________ Math helpers _______________________

def vecMatMult(c1, R1):
    res = Array(n, sint)
    for j in range(n):
        sum = sint(0)
        for k in range(n):
            sum = sum + c1[k]*R1[k][j]
        res[j] = sum
    return res

def vecSub(vec1, vec2):
    res = Array(n, sint)
    for i in range(n):
        res[i] = vec1[i] - vec2[i]
    return res


# _____________________ main functionality _______________________

# KEM decapsulation:
def kem_decap(ct1, ct2, R1):
    x = vecSub(ct2, vecMatMult(ct1, R1))
    w = [centre(x_i) for x_i in x]
    k = [w_i[nu - 1].bit_xor(w_i[nu+1 - 1]) for w_i in w]
    return k

def validity_check():
    pass

# Hash check:
def hash_check(k_angle, c_2, c_3):
    # Distributed hashing to get <t>
    k_angle_sintbit = [sintbit(x_i) for x_i in k_angle] # Convert to sintbit to indicate that they contain bits.
    k_angle_sbit = [sbit(x_i) for x_i in k_angle_sintbit] # Conversion from sintbit to sbit can be done in any domain.
    input = c_2 + k_angle_sbit  # Have to reverse inputs since lists of bits have index 0 to contain lsb, whereas hashing expects the order to be reversed

    to_hash = sbitvec.from_vec(input) #.reverse_bytes()
    t_angle = sha3_256(to_hash) # Note: Input and output for sha3_256 are bit-reversed

    # Compare t and c_3
    for i in range(len(t_angle.v)):
        current_bit = cbit(t_angle.v[i].reveal())
        c_3[i].bit_xor(current_bit).print_if("Fail")
 
# Message extraction
def msg_ext(k_angle):
    k_bits_clear = Array(n, cint)
    for i in range(len(k_angle)):
        k_bits_clear[i] = k_angle[i].reveal()
    k_bits_clear.print_reveal_nested()

# _____________________ I/O _______________________ 

def read_R1_from_file():
    R1 = Matrix(n, n, sint)
    for i in range(n):
        for j in range(n):
            R1[i][j] = sint.get_input_from(0)

    return R1

def read_public_values_from_file():
    ct1 = Array(n, cint)
    ct2 = Array(n, cint)
    c2 = [cbit(0)] * (256+128)
    c3 = [cbit(0)] * 256
    A1 = Matrix(n, n, cint)
    A2 = Matrix(n, n, cint)

    for i in range(n):
        ct1[i] = public_input()

    for i in range(n):
        ct2[i] = public_input()

    """for i in range(256+128): # IV + C2
        c2[i] = cbit(public_input())

    for i in range(256):
        c3[i] = cbit(public_input())

     for i in range(n):
        for j in range(n):
            A1[i][j] = cbit(public_input())

    for i in range(n):
        for j in range(n):
            A2[i][j] = cbit(public_input()) """

    return ct1, ct2, #c2, c3 , A1, A2 

# _____________________ main _______________________

def run_ddec(R1, ct1, ct2, c2, c3):
    k = kem_decap(ct1, ct2, R1)
    hash_check(k, c2, c3)
    msg_ext(k)

R1 = read_R1_from_file()
ct1, ct2 = read_public_values_from_file()

k = kem_decap(ct1, ct2, R1)
msg_ext(k)

